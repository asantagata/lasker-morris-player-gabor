Team Gabor: Alexander Santagata, Nora Cleary, Era Kalaja

Contributions: As a team we did pair programming and used VSCode liveshare to actively work on the code together. All code was written together with the entire group participating fully. 

To compile and run: java Gabor.java 

Evaluation function: Our evaluation function takes in a board (2d array) and an array of 6 counts (each player's piece count in the hand, on the board, and removed pieces.) It begins by checking if the board is terminal using the evaluation function, and if so it returns -1000 for a loss and 1000 for a win. Otherwise, it starts with an evaluation of 0. It adds 100 for each removed enemy piece and subtracts 100 for each removed Gabor piece. Then it finds the number of mills and partial-mills (lines with two pieces from the same player and one empty space, i.e., places that are "one move away" from a mill) for each player. For each Gabor mill or partial-mill it adds 15, for each enemy mill or partial-mill it subtracts 10. With this, it returns the evaluation.

Utility function: Our utility function applies similar scores to terminal nodes as our evaluation function does. For example, when a terminal node is reached, if the AI player (Gabor) has won then the utility returns a score of 1000, if Gabor has lost then it returns a score of -1000, and if it is a tie then the utility returns 0.  

Heuristics: We used iterative deepening to expand our tree without exceeding the time limit. We explore the tree for up to 4.9 seconds, which generally reaches up to depth 5, before stopping the search. If the time limit is reached before an entire depth is searched, the move is determined from the previous depth, as we want to make our decision based on every possible node at a given depth, leaving no node in a depth unexplored. 

Results: To test our program we first ran it against a copy of itself with the referee. We analyzed each move taken and categorized it as good or bad. When we saw generally good moves being well we gained more confidence in our code, when we saw bad moves we edited the code to adjust accordingly. We then tested the player by running it locally in the terminal and providing our own moves. We tested all different types of moves: invalid, good, bad, and mixed to ensure that the program caught all edge cases and played well both offensive and defensively. It did well against us human players and even caught us off guard at times with its good move; it almost always blocked mills when it needed to while also creating mill opportunities for itself. Finally, to see how it performed against another intelligent evaluation function we played its moves against the AI of the official game (found here: https://www.novelgames.com/en/laskermorris/). To do this we would enter the real game’s moves in the terminal and then would provide Gabor’s moves back to the real game to see how it would perform. When we did this the game ended in a tie!

Strengths & Weaknesses: Our program prioritizes the number of its player’s pieces on the board and the number of mills it has formed. The evaluation function we have created is good at detecting a potential opponent mill and blocking the move. However, our player’s weakness is seen when it is picking from board points that neither create a new mill nor block an opponent's mill. Our program picks randomly among the moves with equal evaluation scores, thus it sometimes picks a board point that is trapped between enemy pieces, restricting its ability to make any future moves. Ideally, a board point with empty adjacent board points would be favored over a trapped board point. When playing against itself, Gabor tends to result in a tie, which indicates the first player in a Gabor-vs.-Gabor game does not have much advantage.

Why our heuristics/evaluation function are good choices: Our heuristics, namely iterative deepening, are good choices because these allow Gabor to predict the results of minimax without playing out entire games. As mentioned, iterative deepening usually allows Gabor to reach a depth of 5 moves, which allows us to see mills, removals, and other events that will happen in our next move. Our evaluation function is strong and has been refined over many tests. We chose to prioritize the number of pieces as this decides wins and losses. We also check for both mills and partial mills as described above, which allows Gabor to prioritize making its own mills and blocking enemy mills.
